#!/bin/bash

export MARKPATH=$HOME/.marks

if [ ! -d "$MARKPATH" ]; then
    mkdir -p "$MARKPATH"
fi

# Source bash completion if installed
if [ -f "/etc/bash_completion" ]; then
    . /etc/bash_completion
elif [ -f "$(brew --prefix 2>/dev/null)/etc/bash_completion" ]; then
    . "$(brew --prefix 2>/dev/null)/etc/bash_completion"
fi

# Merge chsdir function
# https://code.google.com/p/easyscripts/wiki/chsdir
CHSDIR_BIN="$HOME/.chsdir"

# Print error messges
function _err()
{
    echo -e "\033[1;31m[ERROR] $@\033[0m" >&2
}

# Print notice messages
function _info()
{
    echo "[INFO] $@"
}

# Jump to predefined mark
function jump()
{ 
    local name=$1

    if [ -z "$name" ]; then
        cd # jump to home directory
    elif [ "$name" = "-" ]; then
        cd - # jump to last visited directory
    elif [ -d "$name" ]; then
        cd "$name" # jump to the directory directly
    else # jump to mark directory
        # Generate all complete results
        local mark_list=($(compgen -f -- "$MARKPATH/$name"))

        if [ ${#mark_list[@]} -eq 0 ]; then
            # invalid mark name, print error
            _err "No such mark: $name"
            return 1
        elif [ ${#mark_list[@]} -eq 1 ]; then
            # only one result, jump right now
            cd -P "${mark_list[0]}"
        else # multiple results, show select menu
            select name in ${mark_list[@]}; do
                cd -P "$name" && break
            done
        fi
    fi
}

# Mark a directory
function mark()
{ 
    local cur="$(pwd)"
    local name="$1"

    if [ -z "$name" ]; then
        # use basename as mark name by default
        name=$(basename "$cur")
    fi

    # Convert mark name to lowercase
    name=$(echo "$name" | tr A-Z a-z)

    # Create a symbolic link to current directory
    if ln -snf "$cur" "$MARKPATH/$name"; then
        _info "Create mark '$name -> $cur' successfully"
        return 0
    else
        _err "Create mark '$name -> $cur' failed"
        return 1
    fi
}

# Unmark a directory
function unmark()
{ 
    local name="$1"

    if [ -z "$name" ]; then # Default to unmark current directory
        name=$(marks | awk -F'->' '{ if ($2 ~ "'"$(pwd)"'$") {print $1} }' | sed 's/ *//g')
    fi

    if [ -z "$name" ]; then
        _err "No mark points to current directory"
        return 1
    elif [ ! -L "$MARKPATH/$name" ]; then
        # No valid mark found
        _err "No such mark: $name"
        return 1
    else
        local target="$(readlink $MARKPATH/$name)"

        # Delete the symbolic link
        if unlink "$MARKPATH/$name"; then
            _info "Delete mark '$name -> $target' successfully"
            return 0
        else
            _err "Delete mark '$name -> $target' failed"
            return 1
        fi
    fi
}

# List the predefined marks
function marks()
{
    local file

    for file in $MARKPATH/*; do
        if [ ! -L "$file" ]; then
            continue
        fi

        if [ ! -e "$file" ]; then # clean broken symbolic links
            unlink "$file"
        else
            printf "%-15s -> %s\n" "$(basename "$file")" "$(readlink "$file")"
        fi
    done
}

# Set auto bash completion for command jump or umark
function _completemarks()
{
    local cword=${COMP_WORDS[COMP_CWORD]}
    local mark_list=$(marks | awk -F '->' '{print $1}' | sed 's/ *$//g')

    # Only do complete on first argument
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($(compgen -W "${mark_list[@]}" -- "$cword"))
    else
        COMPREPLY=()
    fi

    return 0
}

# Enhance file and directory expansion
# Taken from https://code.google.com/p/easyscripts/wiki/chsdir
function _filedir()
{
    local i IFS=$'\n' xspec

    _tilde "$cur" || return 0

    local -a toks
    local quoted tmp

    _quote_readline_by_ref "$cur" quoted
    toks=( ${toks[@]-} $(
        compgen -d -- "$quoted" | {
            while read -r tmp; do
                # TODO: I have removed a "[ -n $tmp ] &&" before 'printf ..',
                #       and everything works again. If this bug suddenly
                #       appears again (i.e. "cd /b<TAB>" becomes "cd /"),
                #       remember to check for other similar conditionals (here
                #       and _filedir_xspec()). --David
                printf '%s\n' $tmp
            done
        }
    ))

    if [[ "$1" != -d ]]; then
        # Munge xspec to contain uppercase version too
        [[ ${BASH_VERSINFO[0]} -ge 4 ]] && \
            xspec=${1:+"!*.@($1|${1^^})"} || \
            xspec=${1:+"!*.@($1|$(printf %s $1 | tr '[:lower:]' '[:upper:]'))"}
        toks=( ${toks[@]-} $( compgen -f -X "$xspec" -- $quoted) )
    fi
    [ ${#toks[@]} -ne 0 ] && _compopt_o_filenames

	chs=($($CHSDIR_BIN "x$1" "$cur"))
	COMPREPLY=( "${COMPREPLY[@]}" "${toks[@]}" "${chs[@]}" )
}

function _filedir_xspec()
{
    local IFS cur xspec

    IFS=$'\n'
    COMPREPLY=()
    _get_comp_words_by_ref cur

    _expand || return 0

    # get first exclusion compspec that matches this command
    xspec=$( awk "/^complete[ \t]+.*[ \t]${1##*/}([ \t]|\$)/ { print \$0; exit }" \
        "$BASH_COMPLETION" )
    # prune to leave nothing but the -X spec
    xspec=${xspec#*-X }
    xspec=${xspec%% *}

    local -a toks
    local tmp

    toks=( ${toks[@]-} $(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            # see long TODO comment in _filedir() --David
            printf '%s\n' $tmp
        done
        }
        ))

    # Munge xspec to contain uppercase version too
    eval xspec="${xspec}"
    local matchop=!
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!}
        matchop=@
    fi
    [[ ${BASH_VERSINFO[0]} -ge 4 ]] && \
        xspec="$matchop($xspec|${xspec^^})" || \
        xspec="$matchop($xspec|$(printf %s $xspec | tr '[:lower:]' '[:upper:]'))"

    toks=( ${toks[@]-} $(
        eval compgen -f -X "!$xspec" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [ -n $tmp ] && printf '%s\n' $tmp
        done
        }
        ))

    [ ${#toks[@]} -ne 0 ] && _compopt_o_filenames

    chs=($($CHSDIR_BIN "x$1" "$cur"))
    COMPREPLY=( "${toks[@]}" "${chs[@]}" )
}

# Create aliases for convenience

# Think: jump or go to
alias j=jump
alias g=jump 

# Think: unmark or delete
alias u=unmark
alias d=unmark

# Think: mark or save a mark
alias m=mark
alias s=mark

# Think: list marks or print marks
alias l=marks
alias p=marks

# Set auto complete for mark-directory
complete -o default -o nospace -F _completemarks jump j g
complete -o nospace -F _completemarks unmark u d

# Set chsdir completion
complete -o filenames -F _filedir_xspec file j g
